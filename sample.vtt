WEBVTT

00:00:20.719 --> 00:00:27.539
好的,那个谁讲,可以听得听吗?

00:00:30.179 --> 00:00:31.660
可以的,可以的。

00:01:10.819 --> 00:01:12.299
那个是谁讲吗,诗涛?

00:01:14.299 --> 00:01:17.519
是我讲,我讲那个论文,Metagraph。

00:01:19.700 --> 00:01:21.060
我共享一下屏幕。

00:01:31.489 --> 00:01:37.310
OK,我来讲一下这篇这个Metagraph,

00:01:37.310 --> 00:01:40.310
然后Metagraph它其实就是,

00:01:40.769 --> 00:01:43.810
我觉得跟上次学的那个Lexi,

00:01:43.810 --> 00:01:47.409
就上次我看的那篇LexiMap还是有一点相像之处的,

00:01:47.409 --> 00:01:51.409
但是我感觉比LexiMap好像更加的robust一点。

00:01:51.409 --> 00:01:58.409
那么它是一个在大规模生物序列库中实现高效并且准确的这个全文本搜索的一个框架。

00:01:59.010 --> 00:02:03.109
然后以下是这篇文章的作者,

00:02:03.109 --> 00:02:08.009
然后基本上都是从ETH这个学校的。

00:02:10.409 --> 00:02:13.710
然后他所遇到的这个主要的挑战首先是,

00:02:13.710 --> 00:02:15.909
这个数据库的规模报道性的增长。

00:02:15.909 --> 00:02:19.909
然后第二个就是它有一个全文本搜索的不可行性,

00:02:19.909 --> 00:02:22.009
也就是长期以来这个,

00:02:22.009 --> 00:02:30.409
就是Petabase,就是Pet字节级别的这个原始测试数据是一直没有办法进行全文本搜索的。

00:02:30.409 --> 00:02:37.710
那它这里的全文本搜索的意思是检索所有包含与给定的查询序列相似序列的数据集。

00:02:37.710 --> 00:02:41.310
那么这篇文章就为了解决,

00:02:41.310 --> 00:02:43.310
就需要解决这个框架。

00:02:43.710 --> 00:02:44.710
就需要解决这个问题。

00:02:44.710 --> 00:02:46.810
那么还有一些现有的工具。

00:02:48.610 --> 00:02:52.310
现有的工具有比如说这个草图技术。

00:02:52.310 --> 00:02:53.810
那么这个草图技术呢,

00:02:53.810 --> 00:02:59.610
就是基于这个哈希算法去生成这个数据的一个比较紧凑的摘要。

00:02:59.610 --> 00:03:05.610
然后这个摘要去用来去做近似级的相似性和包含的查询。

00:03:05.610 --> 00:03:10.409
但是他提的一个例子就是叫Pebble Scout这个工具。

00:03:10.409 --> 00:03:13.210
然后虽然说他觉得这个扩展性很强,

00:03:13.210 --> 00:03:17.310
但是他会缺乏比较敏感的比对支持,

00:03:17.310 --> 00:03:19.810
并且存在比较高的假阳性率。

00:03:19.810 --> 00:03:22.710
这个是草图技术,草图技术局限。

00:03:22.710 --> 00:03:27.409
另外一个叫这个Approximate Membership Query Data Structure。

00:03:27.409 --> 00:03:32.610
然后他的代表的一个技术是Bloom Filters。

00:03:32.610 --> 00:03:38.310
那么他主要是用于对序列集合进行单个短序列的近似查询。

00:03:38.310 --> 00:03:43.009
但是这边提到的比如说COBS方法和KM index,

00:03:43.009 --> 00:03:47.810
他也存在有比较强的这种假阳性的匹配问题。

00:03:47.810 --> 00:03:52.610
也就是他们会错误的报告一个序列是存在于数据集当中的。

00:03:52.610 --> 00:03:56.210
然后这样的话就不太好。

00:03:56.210 --> 00:04:00.610
第三个就是精确表示的带注式的Debruin图。

00:04:00.610 --> 00:04:03.509
那么这种做法是可以保证精确性,

00:04:03.509 --> 00:04:07.710
但是它在可扩展性和查询功能多样性之间难以保持平衡。

00:04:07.710 --> 00:04:12.210
那么现有的这个带注式Debruin图的查询功能多样性比较少。

00:04:12.210 --> 00:04:12.810
也就是,

00:04:12.810 --> 00:04:17.009
很可能只能支持比如说KM的精确匹配。

00:04:17.009 --> 00:04:24.410
所以说这篇论文就是基于这个精确表示的带注式Debruin图的这个想法,

00:04:24.410 --> 00:04:31.379
去进一步深挖得到的一个比较完整的框架。

00:04:31.379 --> 00:04:33.779
那么Metagraph其实它的核心想法,

00:04:33.779 --> 00:04:37.980
也就是说它其实主要做的事情就是去构建了一个索引。

00:04:37.980 --> 00:04:40.579
那么这个索引它是两块东西组成的。

00:04:40.579 --> 00:04:43.980
那么第一块就是一个叫KM字典的东西。

00:04:43.980 --> 00:04:45.079
那么这个KM字典,

00:04:45.079 --> 00:04:47.879
其实本质上就是一个Debruin图。

00:04:47.879 --> 00:04:49.879
可以看看右边,

00:04:49.879 --> 00:04:50.779
这个这块,

00:04:50.779 --> 00:04:51.879
右上角这块,

00:04:51.879 --> 00:04:54.579
其实就是他们构建的一个Debruin Graph。

00:04:54.579 --> 00:04:56.680
这个Debruin Graph具体是什么东西呢?

00:04:56.680 --> 00:04:58.779
就是它会存,

00:04:58.779 --> 00:05:02.180
它会根据KM的信息,

00:05:02.180 --> 00:05:04.079
把这个不同的,

00:05:04.079 --> 00:05:12.879
把这个存在K典一个重合的这个KM用一根有象的线段连起来。

00:05:12.879 --> 00:05:14.079
那么这样的话,

00:05:14.079 --> 00:05:14.879
整个一个,

00:05:14.879 --> 00:05:20.279
整个一个数据库就会被以一种图的形式存下来。

00:05:20.279 --> 00:05:22.079
然后存的过程中,

00:05:22.079 --> 00:05:24.680
其实这个有象的线段是不需要存,

00:05:24.680 --> 00:05:25.680
它其实只要存,

00:05:25.680 --> 00:05:28.279
就比如说这个这个TCG,

00:05:28.279 --> 00:05:30.279
CCT和GTA就可以了,

00:05:30.279 --> 00:05:34.279
它并不需要存中间这个连接的这根线段,

00:05:34.279 --> 00:05:40.480
因为通过存储的这个set就可以还原出来整个Graph的一个样子。

00:05:40.480 --> 00:05:42.579
然后这是KM字典,

00:05:42.579 --> 00:05:44.680
那么它既然还需要,

00:05:44.680 --> 00:05:47.180
就是一些别的信息,

00:05:47.180 --> 00:05:51.079
就比如说你给它一个query查询的一个段,

00:05:51.079 --> 00:05:52.480
然后你需要知道它,

00:05:52.480 --> 00:05:53.680
比如说这个,

00:05:53.680 --> 00:05:56.579
这个这一段基因是从哪里来的,

00:05:56.579 --> 00:05:58.779
以及这段基因可能拥有的其他信息,

00:05:58.779 --> 00:06:00.879
包括但不限于这个分类信息什么的,

00:06:00.879 --> 00:06:03.480
所以它还需要一个注视,

00:06:03.480 --> 00:06:05.279
它还需要一层注视,

00:06:05.279 --> 00:06:07.079
那么为了这个需求,

00:06:07.079 --> 00:06:10.079
它就是构建了一个叫注视矩阵的东西,

00:06:10.079 --> 00:06:13.379
和这个上面提到这个Debruing Graphs联合在一起,

00:06:13.379 --> 00:06:14.379
就可以,

00:06:14.680 --> 00:06:20.180
就理论上可以完成这个序列的查询工作。

00:06:20.180 --> 00:06:24.079
那么接下来可以继续想一想的Kimmer Set,

00:06:24.079 --> 00:06:28.579
这个Kimmer Set它这个存储的方式,

00:06:28.579 --> 00:06:30.180
它这边提到了三种,

00:06:30.180 --> 00:06:33.180
那么首先是一个叫Hash DBG的东西,

00:06:33.180 --> 00:06:34.879
这个Hash DBG呢,

00:06:34.879 --> 00:06:36.879
就是主要用于内部的操作,

00:06:36.879 --> 00:06:39.379
比如说P处理的序列查找,

00:06:39.379 --> 00:06:41.779
然后第二个叫Bitmap DBG,

00:06:41.779 --> 00:06:43.180
就是它把Kimmer,

00:06:43.180 --> 00:06:47.579
因为Kimmer的这个可能的Kimmer其实数量是有限的,

00:06:47.579 --> 00:06:50.279
那么它就把它存储成一个二进制向量,

00:06:50.279 --> 00:06:54.879
就表示哪一些Kimmer存在于这个集合当中。

00:06:54.879 --> 00:06:58.579
那么第三个东西就是Succinct DBG,

00:06:58.579 --> 00:07:01.779
那么它是基于一个东西叫BOSS表构写的,

00:07:01.779 --> 00:07:06.480
这BOSS其实是四个人的首字母加在一起,

00:07:06.480 --> 00:07:10.980
然后这其实是类似于一个就是点七,

00:07:10.980 --> 00:07:12.279
就是类似点七的,

00:07:12.279 --> 00:07:14.680
或者点ZIP的一种压缩文件格式,

00:07:14.680 --> 00:07:17.480
但是是专门为了这种DNA sequence,

00:07:17.480 --> 00:07:19.980
RNA sequence去做的,

00:07:19.980 --> 00:07:22.079
那么使用这种构件呢,

00:07:22.079 --> 00:07:23.980
会表现出最佳的压缩性能,

00:07:23.980 --> 00:07:26.779
那么这也是作为默认的一种压缩表示的,

00:07:26.779 --> 00:07:32.420
用来减少这个索引的大小,

00:07:32.420 --> 00:07:34.720
然后接下来就说一说这个,

00:07:34.720 --> 00:07:39.019
去具体说一说这个注释矩阵它是怎么做的,

00:07:39.019 --> 00:07:43.120
那么它的注释矩阵其实就是一个N乘M的一个,

00:07:43.120 --> 00:07:44.420
N乘M的一个01,

00:07:44.620 --> 00:07:48.519
那么N乘M的01比如说长这样,

00:07:48.519 --> 00:07:54.060
然后我们看比如说它DI行,

00:07:54.060 --> 00:07:56.360
DJ列,

00:07:56.360 --> 00:08:00.509
如果DI行DJ列这个东西是1呢,

00:08:00.509 --> 00:08:08.209
那说明了就是这个从列来看是这个K门,

00:08:08.209 --> 00:08:10.310
从行来看呢就是这个数,

00:08:10.310 --> 00:08:12.110
就是D这个属性,

00:08:12.110 --> 00:08:16.810
那么它的意思就是DI个K门会具有D这个属性,

00:08:16.810 --> 00:08:17.709
它是用D,

00:08:17.709 --> 00:08:19.610
用这样的方式来,

00:08:19.610 --> 00:08:21.810
然后它当然旁边可能还会有张表,

00:08:21.810 --> 00:08:25.509
就比如说DJ一个属性,

00:08:25.509 --> 00:08:29.819
那么具体的属性是什么,

00:08:29.819 --> 00:08:34.120
那么它通过这一张I乘J的这张表01表,

00:08:34.120 --> 00:08:40.419
其实就表明了比如说具体的哪个K门,

00:08:40.419 --> 00:08:43.220
哪些K门会具有J的这个属性,

00:08:43.220 --> 00:08:47.720
那么从这个图上其实大概可以看出来它里面会存在很多0,

00:08:47.720 --> 00:08:49.919
所以说这个矩阵其实是,
